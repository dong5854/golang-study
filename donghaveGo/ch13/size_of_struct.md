# 구조체 크기

구조체 변수가 선언되면 컴퓨터는 구조체 필드를 모두 모두 담을 수 있는 메머리 공간을 할당한다.
``` go
type User struct {
    Age   int
    Score float64
}
```
위와 같은 구조체 User가 정의되어 있다고 한다면,
``` go
var user User
```
User 구조체의 user 변수가 선언되면 컴퓨터는 Age와 Score 필드를 연속되게 담을 수 있는 메모리 공간을 찾아 할당한다. int 타입 Age는 8바이트, float64 타입 Score 역시 8바이트이므로 총 16바이트가 필요하다. 즉 구조체 변수 user의 크기는 16바이트가 된다. 따라서 User도 16바이트이다.

# 필드 배치 순서에 따른 구조체 크기 변화

`struct_size_change.go` 의 코드를 살펴보자.
``` go
package main

import (
	"fmt"
	"unsafe"
)

type User struct {
	Age   int32   // 4바이트
	Score float64 // 8바이트
}

func main() {
	user := User{23, 77.2}
	fmt.Println(unsafe.Sizeof(user))
}
```
위 코드의 실행 결과는 아래와 같다.
```
16
```
Age를 기존 int 타입에서 int32 타입으로 바꿨다. int 크기는 8바이트이고, int32는 4바이트이다. `unsafe.Sizeof()` 함수는 해당 변수의 메모리 공간 크기를 반환한다. 앞에서 배운 대로라면 이번 구조체의 크기는 12바이트여야 하는데 웬일인지 16 바이트로 출력된다. 이런 결과가 나오는 이유는 메모리 정렬 때문이다.

## 메모리 정렬
메모리 정렬이란 컴퓨터가 데이터에 효과적으로 접근하고자 메모리를 일정 크기 간격으로 정렬하는 것을 말한다. 레지스터는 실제 연산에 사용되는 데이터가 저장되는 곳인데, 레지스터 크기가 8바이트라는 애기는 한 번 연산에 8바이트 크기를 연산할 수 있다는 이야기이다. 따라서 데이터가 레지스터 크기와 똑같은 크기로 정렬되어 있으면 더욱 효율적으로 데이터를 읽어올 수 있다.
**즉, 64 비트 컴퓨터는 메모리가 8바이트 단위로 정렬되어 있는 것이 효율적이다.**

예를 들자면 64 비트 컴츄터에서 int64 데이터의 시작 주소가 100번지일 경우 100은 8의 배수가 아니기 때문에 레지스터 크기인 8에 맞게 정렬되어 있지 않기 때문에 데이터를 메모리에서 읽어올 때 성능을 손해본다. 따라서 처음부터 프로그램 언어에서 데이터를 만들 때 8의 배수인 메모리 주소에 데이터를 할당한다. 이 경우 100번지가 아니라 8의 배수인 104 번지에 할당된다.

앞의 예의 구조체를 다시 살펴보면
``` go
type User struct {
	Age   int32   // 4바이트
	Score float64 // 8바이트
}

var user User
```

Age는 4바이트 Score는 8바이트이다. User 구조체 변수 user의 시작 주소가 240번지라면 Age의 시작 주소 역시 240번지가 된다.
Age는 4바이트 공간을 차지하기 때문에 바로 붙어서 Score를 할당하면 Score의 시작 주소는 244번지가 되는데 이렇게 되면 244는 8의 배수가 아니라서 성능을 손해본다. 그래서 프로그램 언어에서 User 구조체를 할당할 때는 Age와 Score사이를 4바이트 만큼 띄워서 할당한다.

따라서,
```
240 -> Age
241 -> Age
242 -> Age
243 -> Age
244 -> Score
245 -> Score
246 -> Score
247 -> Score
248 -> Score
249 -> Score
250 -> Score
251 -> Score
```
가 아니라
```
240 -> Age
241 -> Age
242 -> Age
243 -> Age
244 -> empty
245 -> empty
246 -> empty
247 -> empty
248 -> Score
249 -> Score
250 -> Score
251 -> Score
252 -> Score
253 -> Score
254 -> Score
255 -> Score
```
가 되어 16바이트가 된다.

이렇게 메모리 정렬을 위해 필드 사이에 공간을 띄우는 것을 메모리 패딩(Memory Padding)이라고 한다. 참고로 4바이트 변수의 시작 주소는 4의 배수로 맞추고, 2바이트 변수의 시작 주소는 2의 배수로 맞춰서 패딩한다. 이는 이렇게 맞추는 것이 컴퓨터 내부에서 처리하기에 더 효율적이기 때문이다.

## 메모리 패딩을 고려한 필드 배치
`memory_padding_problem.go` 코드를 보자
``` go
package main

import (
	"fmt"
	"unsafe"
)

type User struct {
	A int8 // 1바이트
	B int  // 8바이트
	C int8 // 1바이트
	D int  // 8바이트
	E int8 // 1바이트
}

func main() {
	user := User{1, 2, 3, 4, 5}
	fmt.Println(unsafe.Sizeof(user)) // 40이 출력
}
```
user 구조체는 1바이트짜리 필드 3개와 8바이트짜리 필드 2개로 구성되어 있기 때문에 19 바이트 크기를 차지한다. 하지만 1 바이트 변수 A, C, E에 7바이트씩 패딩되어 실제 구조체 크기는 40 바이트가 된다.

이런 메모리 낭비를 줄이기 위해 8 바이트보다 작은 필드는 8바이트 크기를 고려해 몰아서 배치할 수 있다.

`memory_padding_solved.go` 와 같은 배치를 통해 메모리 낭비를 줄일 수 있다.
``` go
package main

import (
	"fmt"
	"unsafe"
)

type User struct {
	A int8 // 1바이트
	C int8 // 1바이트
	E int8 // 1바이트
	B int  // 8바이트
	D int  // 8바이트
}

func main() {
	user := User{1, 2, 3, 4, 5}
	fmt.Println(unsafe.Sizeof(user)) //24가 출력
}
```
이렇게 하면 A,C,E에 각각 7바이트씩 패딩되지 않고

```
0 -> A
1 -> C
2 -> E
3 -> empty
4 -> empty
5 -> empty
6 -> empty
7 -> empty
8~15 -> B
16~23 -> D
```
와 같이 배치되어 구조체 크기가 24가 되어 16바이트를 절약 할 수 있다.

메모리 용량이 충분한 데스크톱 애플리케이션이라면 크게 걱정하지 않아도 되는 부분이지만 메모리 공간이 작은 임베디드 하드웨어라면 고려하는 것이 좋다.